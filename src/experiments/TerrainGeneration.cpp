// ----------------------------- TerrainGeneration ----------------------------------
//   Summer of 2024
// ..................................................................................
/*
 * Experiments for constructing a triangulated terrain generated by Perlin noise.
 * Multiple libraries are compared, including the free version of commercial Fade library.
 */
 // --------------------------------------------------------------------------------

#include "geometry/TerrainBuilder.h"
#include "geometry/TriangulationUtils.h"

#include "IOEnvironment.h"
#include "../Experiments.h"

void TerrainPtGenerationTest()
{
	// Define boundaries for each example
	std::vector<std::vector<pmp::Point>> boundaries = {
		// Example 1: Square with side 100 units
		{
			pmp::Point(0, 0, 0),
			pmp::Point(100, 0, 0),
			pmp::Point(100, 100, 0),
			pmp::Point(0, 100, 0)
		},
		// Example 2: Triangle of roughly the same size as the 100-unit side square
		{
			pmp::Point(0, 0, 0),
			pmp::Point(100, 0, 0),
			pmp::Point(50, 86.6f, 0) // Height of an equilateral triangle with side length 100 units
		},
		// Example 3: More complicated concave polygon
		{
			pmp::Point(0, 0, 0),
			pmp::Point(100, 0, 0),
			pmp::Point(100, 50, 0),
			pmp::Point(50, 50, 0),
			pmp::Point(50, 100, 0),
			pmp::Point(0, 100, 0)
		}
	};

	// Iterate through each boundary and generate terrain
	int exampleIndex = 1;
	for (const auto& boundary : boundaries)
	{
		// Set up terrain settings
		Geometry::TerrainSettings settings;
		settings.BoundaryLoopPolyline = boundary;
		settings.MinElevation = 0.0f;
		settings.MaxElevation = 60.0f;
		settings.SamplingRadius = 1.0f;
		settings.SamplingAttempts = 30;
		settings.NoiseScale = 50.0f;  // Increased to match the terrain scale
		settings.Octaves = 3;         // Reduced for less noise
		settings.Persistence = 0.3f;  // Reduced for smoother transitions
		settings.Lacunarity = 1.5f;   // Reduced to space out features
		settings.Seed = 4999;

		// Create terrain builder
		Geometry::TerrainBuilder terrainBuilder(settings);
		terrainBuilder.GeneratePoints();
		Geometry::BaseMeshGeometryData terrainMeshData = terrainBuilder.GetResult();

		// Export to PLY file
		std::string outputFileName = dataOutPath + "terrain_example_" + std::to_string(exampleIndex) + ".ply";
		if (!Geometry::ExportPointsToPLY(terrainMeshData, outputFileName))
		{
			std::cout << "Failed to export mesh data for example " << exampleIndex << ".\n";
			continue;
		}

		std::cout << "Terrain example " << exampleIndex << " exported to " << outputFileName << "\n";
		exampleIndex++;
	}
}

void TerrainTriangulationTest()
{
	// Define boundaries for each example
	std::vector<std::vector<pmp::Point>> boundaries = {
		// Example 1: Square with side 100 units
		{
			pmp::Point(0, 0, 0),
			pmp::Point(100, 0, 0),
			pmp::Point(100, 100, 0),
			pmp::Point(0, 100, 0)
		},
		// Example 2: Triangle of roughly the same size as the 100-unit side square
		{
			pmp::Point(0, 0, 0),
			pmp::Point(100, 0, 0),
			pmp::Point(50, 86.6f, 0) // Height of an equilateral triangle with side length 100 units
		},
		// Example 3: More complicated concave polygon
		{
			pmp::Point(0, 0, 0),
			pmp::Point(100, 0, 0),
			pmp::Point(100, 50, 0),
			pmp::Point(50, 50, 0),
			pmp::Point(50, 100, 0),
			pmp::Point(0, 100, 0)
		}
	};

	// Iterate through each boundary and generate terrain
	int exampleIndex = 1;
	for (const auto& boundary : boundaries)
	{
		// Set up terrain settings
		Geometry::TerrainSettings settings;
		settings.BoundaryLoopPolyline = boundary;
		settings.MinElevation = 0.0f;
		settings.MaxElevation = 60.0f;
		settings.SamplingRadius = 1.0f;
		settings.SamplingAttempts = 30;
		settings.NoiseScale = 50.0f;  // Increased to match the terrain scale
		settings.Octaves = 3;         // Reduced for less noise
		settings.Persistence = 0.3f;  // Reduced for smoother transitions
		settings.Lacunarity = 1.5f;   // Reduced to space out features
		settings.Seed = 4999;

		// Create terrain builder
		Geometry::TerrainBuilder terrainBuilder(settings);
		terrainBuilder.GeneratePoints();

		terrainBuilder.Triangulate([&boundary](Geometry::BaseMeshGeometryData& data) { Geometry::TriangulateWithFade2D(data, boundary); });
		//terrainBuilder.Triangulate([&boundary](Geometry::BaseMeshGeometryData& data) { Geometry::TriangulateWithVCGBPA(data); });
		//terrainBuilder.Triangulate([&boundary](Geometry::BaseMeshGeometryData& data) { Geometry::TriangulateWithPoly2Tri(data, boundary); });

		Geometry::BaseMeshGeometryData terrainMeshData = terrainBuilder.GetResult();

		// Export to PLY file
		std::string outputFileName = dataOutPath + "terrain_example_" + std::to_string(exampleIndex) + ".obj";
		if (!Geometry::ExportBaseMeshGeometryDataToOBJ(terrainMeshData, outputFileName))
		{
			std::cout << "Failed to export mesh data for example " << exampleIndex << ".\n";
			continue;
		}

		std::cout << "Terrain example " << exampleIndex << " exported to " << outputFileName << "\n";
		exampleIndex++;
	}
}